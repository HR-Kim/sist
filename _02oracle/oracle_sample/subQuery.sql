/*
Sub Query
Sub 사용가능한 규칙

단일 행 단일 컬럼
SELECT FROM WHERE 모두에서 SUB QUEREY 사용 가능

단일 행 다중 컬럼
FROM WHERE

*/

SELECT LAST_NAME --컬럼이 하나만 있는 것이 단일행 단일 컬럼
FROM EMPLOYEES;

-- 단일 행 단일 컬럼
SELECT FIRST_NAME, (SELECT MAX(SALARY) FROM JOBS)
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);

-- 단일 행 다중 컬럼
SELECT EMPLOYEE_ID,FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE (SALARY, JOB_ID)
  = (SELECT SALARY, JOB_ID
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = 101);

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, SALARY,
  (SELECT SUM(SALARY) FROM EMPLOYEES) AS 월급합,
  (SELECT COUNT(*) FROM EMPLOYEES) AS 카운터,
  (SELECT SUM(SALARY) FROM EMPLOYEES)
  / (SELECT COUNT(*) FROM EMPLOYEES) AS 평균
FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, (SELECT SALARY FROM EMPLOYEES) -- 단일행 단일 컬럼이긴 하지만 1대 다수이기 때문에 실행 오류가 난다.
FROM EMPLOYEES;

--위의 문제를 해결하기 위한 3가지 방법
--1. 그룹함수를 사용

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, (SELECT COUNT(SALARY) FROM EMPLOYEES)
FROM EMPLOYEES;

--2. PRIMARY(첫번째) KEY

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, (SELECT SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 101) 
FROM EMPLOYEES;

--3. Rownum 임의의 컬럼

SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID, (SELECT SALARY FROM EMPLOYEES WHERE ROWNUM = 1)
FROM EMPLOYEES;

-- 단일행 다중 컬럼
select EMPLOYEE_ID, START_DATE, END_DATE, JOB_HISTORY.JOB_ID,
DEPARTMENT_ID
from JOB_HISTORY
where (EMPLOYEE_ID, START_DATE)
  = (select EMPLOYEE_ID, EMPLOYEES.HIRE_DATE
  from EMPLOYEES
  where EMPLOYEE_ID = 102);

--다중행 서브 쿼리(Query_)

SELECT FIRST_NAME, SALARY
from EMPLOYEES
where job_id in (select JOB_ID from jobs);


SELECT FIRST_NAME, SALARY 
FROM EMPLOYEES
WHERE job_id = ANY(SELECT job_id FROM JOBS); -- <-> ALL (AND 조건), ANY (OR 조건)

SELECT FIRST_NAME, SALARY,
    (SELECT AVG(SALARY) 
    FROM EMPLOYEES B
    WHERE A.JOB_ID = B.JOB_ID)
FROM EMPLOYEES A
WHERE A.SALARY > (SELECT AVG(SALARY) 
                  FROM EMPLOYEES B WHERE A.JOB_ID = B.JOB_ID);

-- 특수 쿼리(Query)
/*
  조건 분기
  CASE
*/

SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER,
  CASE SUBSTR(PHONE_NUMBER, 1, 3)
    WHEN '515' THEN '서울'
    WHEN '590' THEN '부산'
    WHEN '659' THEN '대구'
    WHEN '603' THEN '대전'
    ELSE '기타' END AS 지역
FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER,
  CASE WHEN SUBSTR(PHONE_NUMBER, 1, 3) >= '515' THEN '서울'
    WHEN SUBSTR(PHONE_NUMBER, 1, 3) < '590' THEN '부산'
    WHEN SUBSTR(PHONE_NUMBER, 1, 3) = '659' THEN '대구'
    WHEN SUBSTR(PHONE_NUMBER, 1, 3) <= '603' THEN '대전'
    ELSE '기타' END AS 지역
FROM EMPLOYEES;

-- DECODE, NVL1, NVL2
SELECT EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER,
    DECODE(SUBSTR(PHONE_NUMBER, 1, 3),
    '515', '서울',
    '590', '부산',
    '603', '광주',
    '기타') AS 지역
FROM EMPLOYEES;

--NVL1, NVL2
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID,
  NVL(MANAGER_ID, EMPLOYEE_ID),
  NVL2(MANAGER_ID, '직원', '사장') -- (MANAGER_ID = NULL) ? '직원' : '사장'
FROM EMPLOYEES;

--ROWNUM 임의의 컬럼
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER
FROM (
  SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, PHONE_NUMBER
  FROM EMPLOYEES
  order by EMPLOYEES.FIRST_NAME
)
--WHERE ROWNUM < 6;
WHERE ROWNUM >= 3 or rownum = 1; -- 중간에서 실시하면 실행 안된다. 반드시 1은 거쳐야한다.
--WHERE ROWNUM =6;

--ROW_NUMBER()
SELECT ROW_CNT, employee_id, FIRST_NAME, PHONE_NUMBER
FROM (
  SELECT employee_id, FIRST_NAME, PHONE_NUMBER,
  ROW_NUMBER() OVER (ORDER BY FIRST_NAME) AS ROW_CNT
  FROM EMPLOYEES
)
WHERE ROW_CNT < 6;

-- RANK(), DENSE_RANK, ROW_NUMBER()
SELECT FIRST_NAME, JOB_ID, SALARY,
  RANK() OVER (PARTITION BY JOB_ID ORDER BY SALARY DESC) AS RANK,
  DENSE_RANK() OVER (PARTITION BY JOB_ID ORDER BY SALARY DESC) AS DENSE_RANK,
  ROW_NUMBER() OVER (PARTITION BY JOB_ID ORDER BY SALARY DESC) AS ROW_NUMBER
FROM EMPLOYEES;

--집합 연산자
/*
union : 합집합
intersect : 교집합
minus : 차집합
*/

--합집합
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
UNION ALL
SELECT JOB_TITLE, MIN_SALARY
FROM JOBS;

--교집합
SELECT EMPLOYEE_ID
FROM EMPLOYEES
INTERSECT -- 중복된 내용을 배제하고 보여줌
SELECT MANAGER_ID
FROM DEPARTMENTS;

SELECT A.EMPLOYEE_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.EMPLOYEE_ID = B.MANAGER_ID;

SELECT JOB_ID
FROM EMPLOYEES
INTERSECT
SELECT JOB_ID
FROM JOBS;

SELECT DISTINCT A.JOB_ID
FROM EMPLOYEES A, JOBS B
WHERE A.JOB_ID = B.JOB_ID;

--SUB QUERY
SELECT A.JOB_ID
FROM EMPLOYEES A
WHERE A.JOB_ID IN (SELECT B.JOB_ID FROM JOBS B);

SELECT EMPLOYEE_ID
FROM EMPLOYEES
MINUS
SELECT DEPARTMENTS.MANAGER_ID
FROM DEPARTMENTS;

SELECT DISTINCT A.EMPLOYEE_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.EMPLOYEE_ID = B.MANAGER_ID(+)
  AND B.MANAGER_ID IS NULL
  ORDER BY A.EMPLOYEE_ID;
--AND B.MANAGER_ID IS NOT NULL
--ORDER BY A.EMPLOYEE_ID;

--문제1) EMPLOYEES 테이블에서 Kochhar의 급여보다 많은 사원의 정보를 사원번호,이름,담당업무,급여를 출력하라.

SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, A.SALARY
FROM EMPLOYEES A
WHERE SALARY > (SELECT SALARY FROM EMPLOYEES B WHERE B.LAST_NAME = 'Kochhar');

--강사님 풀이
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
where SALARY > (SELECT SALARY
                FROM EMPLOYEES
                WHERE LAST_NAME = 'Kochhar');

--문제2) EMPLOYEES 테이블에서 급여의 평균보다 적은 사원의 정보를 사원번호,이름,담당업무,급여,부서번호를 출력하여라.

SELECT EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, A.SALARY, A.DEPARTMENT_ID 
FROM EMPLOYEES A
WHERE A.SALARY < (SELECT AVG(B.SALARY) FROM EMPLOYEES B);

--강사님 풀이
SELECT EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, A.SALARY, A.DEPARTMENT_ID 
FROM EMPLOYEES A
WHERE SALARY < (SELECT AVG(salary) FROM EMPLOYEES);

--문제3) EMPLOYEES 테이블에서 100번 부서의 최소 급여보다 최소 급여가 많은 다른 모든 부서를 출력하라

SELECT DISTINCT A.DEPARTMENT_ID, 
(SELECT MIN(B.SALARY) FROM EMPLOYEES B
WHERE NVL(A.DEPARTMENT_ID, 0) = NVL(B.DEPARTMENT_ID,0))
FROM EMPLOYEES A
WHERE (SELECT MIN(B.SALARY) FROM EMPLOYEES B
WHERE NVL(A.DEPARTMENT_ID, 0) = NVL(B.DEPARTMENT_ID,0)) > (SELECT MIN(SALARY) FROM EMPLOYEES B WHERE B.DEPARTMENT_ID = 100);

--강사님 풀이

SELECT DEPARTMENT_ID, MIN(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MIN(SALARY) > (SELECT MIN(SALARY)
                      FROM EMPLOYEES
                      WHERE DEPARTMENT_ID = 100);

--문제4) 업무별로 최소 급여를 받는 사원의 정보를 사원번호,이름,업무,부서번호를 출력하여라. 단 업무별로 정렬하여라.

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, A.SALARY,   DEPARTMENT_ID
FROM EMPLOYEES A
WHERE SALARY = (SELECT MIN(B.SALARY) FROM EMPLOYEES B WHERE A.JOB_ID = B.JOB_ID)
ORDER BY A.JOB_ID;

--강사님 풀이
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY,   DEPARTMENT_ID
FROM EMPLOYEES
WHERE (JOB_ID, SALARY) IN (SELECT JOB_ID, MIN(SALARY)
                            FROM EMPLOYEES
                            GROUP BY JOB_ID)
ORDER BY JOB_ID;

--문제5) EMPLOYEES 과 DEPARTMENTS 테이블에서 업무가 세일드맨 사원의 정보를 이름,업무,부서명,근무지를 출력하라.

SELECT A.LAST_NAME, A.JOB_ID, B.DEPARTMENT_NAME, B.LOCATION_ID
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID 
AND A.JOB_ID = 'SA_MAN';

--강사님 풀이
SELECT LAST_NAME, JOB_ID, A.DEPARTMENT_ID, B.DEPARTMENT_NAME, B.LOCATION_ID
FROM (SELECT LAST_NAME, JOB_ID, DEPARTMENT_ID
      FROM EMPLOYEES
      WHERE JOB_ID = 'SA_MAN') A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID;      

--문제6) ?EMP 테이블에서 가장 많은 사원을 갖는 MANAGER의 사원번호를 출력하라.

SELECT *
FROM(
SELECT A.MANAGER_ID,
  COUNT(*)
FROM EMPLOYEES A
GROUP BY A.MANAGER_ID
ORDER BY COUNT(*) DESC)
WHERE ROWNUM = 1; 

--강사님 풀이

SELECT MANAGER_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY MANAGER_ID
HAVING COUNT(MANAGER_ID)
    =(SELECT MAX(COUNT(*))
      FROM EMPLOYEES
      GROUP BY MANAGER_ID);

--문제7) EMP?테이블에서?가장?많은?사원이?속해있는?부서번호와?사원수를?출력하라.

SELECT * 
FROM(
  SELECT A.DEPARTMENT_ID, 
  COUNT(*)
  FROM EMPLOYEES A
  GROUP BY A.DEPARTMENT_ID
  ORDER BY COUNT(*) DESC)
WHERE ROWNUM = 1;

--강사님 풀이

SELECT DEPARTMENT_ID, COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(DEPARTMENT_ID) = (SELECT MAX(COUNT(*))
                               FROM EMPLOYEES
                                GROUP BY DEPARTMENT_ID);

--문제8) ?EMP?테이블에서?사원번호가?123인?사원의?직업과?같고?사원번호가?192인?사원의?급여(SAL)보다?많은?사원의?사원번호,?이름,?직업,?급여를?출력하라.

SELECT A.EMPLOYEE_ID, A.FIRST_NAME, A.JOB_ID, A.SALARY
FROM EMPLOYEES A
WHERE JOB_ID = (SELECT B.JOB_ID FROM EMPLOYEES B WHERE B.EMPLOYEE_ID = 123)
AND A.SALARY > (SELECT B.SALARY FROM EMPLOYEES B WHERE B.EMPLOYEE_ID = 192);

--강사님 풀이

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID
                FROM EMPLOYEES
                WHERE EMPLOYEE_ID = 123)
      AND 
      SALARY > (SELECT SALARY
                FROM EMPLOYEES
                WHERE EMPLOYEE_ID = 192);


--문제9) ? 직업(JOB)별로?최소?급여를?받는?사원의?정보를?사원번호,?이름,?업무,?부서명을?출력하라.
-- 조건1 :?직업별로?내림차순?정렬

SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND A.SALARY = (SELECT MIN(B.SALARY) FROM EMPLOYEES B WHERE A.JOB_ID = B.JOB_ID)
ORDER BY A.JOB_ID DESC;

--강사님 풀이
SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, B.DEPARTMENT_NAME, A.SALARY
FROM EMPLOYEES A, DEPARTMENTS B
WHERE B.DEPARTMENT_ID = A.DEPARTMENT_ID
    AND A.SALARY IN (SELECT MIN(SALARY) 
                    FROM EMPLOYEES 
                    GROUP BY JOB_ID)
ORDER BY A.JOB_ID DESC;

--문제10) EMPLOYEES 테이블에서 업무별로 최소 급여를 받는 사원의 정보를 사원번호,이름,업무,입사일자,급여,부서번호를 출력하라 (IN)

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, HIRE_DATE, SALARY, DEPARTMENT_ID
FROM EMPLOYEES A
WHERE A.SALARY IN (SELECT MIN(B.SALARY) FROM EMPLOYEES B WHERE A.JOB_ID = B.JOB_ID);

--문제11) EMPLOYEES 테이블에서 50번 부서의 최소 급여를 받는 사원 보다 많은 급여를 받는 사원의 정보를 사원번호,이름,업무,입사일자,급여,부서번호를 출력하라. 단 50번은 제외 (ANY)

SELECT A.EMPLOYEE_ID, A.LAST_NAME, A.JOB_ID, A.HIRE_DATE, A.SALARY, A.DEPARTMENT_ID
FROM EMPLOYEES A
WHERE A.SALARY > ANY(SELECT B.SALARY FROM EMPLOYEES B WHERE B.DEPARTMENT_ID = 50)
AND A.DEPARTMENT_ID != 50;

--강사님 풀이
SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, HIRE_DATE, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SALARY > (SELECT MIN(SALARY)
                FROM EMPLOYEES
                WHERE DEPARTMENT_ID = 50)
      AND
      DEPARTMENT_ID != 50;

--문제12) EMPLOYEES 테이블에서 50번 부서의 최고 급여를 받는 사원 보다 많은 급여를 받는 사원의 정보를 사원번호,이름,업무,입사일자,급여,부서번호를출력하라. 단50번은 제외 (ALL)

SELECT *
FROM EMPLOYEES A
WHERE A.SALARY > ALL(SELECT SALARY FROM EMPLOYEES B WHERE B.DEPARTMENT_ID = 50)
AND A.DEPARTMENT_ID != 50;
