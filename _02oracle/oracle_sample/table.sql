alter TABLESPACE TABLESPACE1
RENAME TO TEST_TBS_NEW;

ALTER DATABASE
DATAFILE 'C:\test\FILE_SPECIFICATION1' RESIZE 7M;

/*
TABLE ?
ORACLE에서 가장 기본적인 데이터 저장 단위
COLUMN(세로), ROW(가로)로 표현됩니다

실제 데이터는 TABLESPACE에서 관리가 되며,
데이터 파일에 저장된다.
*/

CREATE TABLESPACE TABLESPACE2
DATAFILE 'C:\TEST\TEST_TBS1_02.DBF' SIZE 10M
AUTOEXTEND ON NEXT 1M MAXSIZE UNLIMITED
LOGGING
EXTENT MANAGEMENT LOCAL AUTOALLOCATE
BLOCKSIZE 8K
SEGMENT SPACE MANAGEMENT AUTO
FLASHBACK ON;

CREATE TABLE TB_TEST2(
  COL1 VARCHAR2(10),
  COL2 VARCHAR2(10),
  COL3 VARCHAR2(10),
  COL4 VARCHAR2(10)
)TABLESPACE TEST_TBS_NEW;

-- ALTER 
ALTER TABLE TB_TEST2 RENAME TO NEW_TB_TEST2;

--COLOUMN 추가  
ALTER TABLE NEW_TB_TEST2
ADD NEW_COL VARCHAR2(30);

--다중 COLOUMN 추가
ALTER TABLE NEW_TB_TEST2
ADD(NEW_COL1 VARCHAR2(30));

--단일 컬럼 수정
ALTER TABLE NEW_TB_TEST2
MODIFY NEW_COL1 VARCHAR2(20);

ALTER TABLE alter TABLESPACE TABLESPACE1
RENAME TO TEST_TBS_NEW;

ALTER DATABASE
DATAFILE 'C:\test\FILE_SPECIFICATION1' RESIZE 7M;

/*
TABLE ?
ORACLE에서 가장 기본적인 데이터 저장 단위
COLUMN(세로), ROW(가로)로 표현됩니다

실제 데이터는 TABLESPACE에서 관리가 되며,
데이터 파일에 저장된다.
*/

CREATE TABLESPACE TABLESPACE2
DATAFILE 'C:\TEST\TEST_TBS1_02.DBF' SIZE 10M
AUTOEXTEND ON NEXT 1M MAXSIZE UNLIMITED
LOGGING
EXTENT MANAGEMENT LOCAL AUTOALLOCATE
BLOCKSIZE 8K
SEGMENT SPACE MANAGEMENT AUTO
FLASHBACK ON;

CREATE TABLE TB_TEST2(
  COL1 VARCHAR2(10),
  COL2 VARCHAR2(10),
  COL3 VARCHAR2(10),
  COL4 VARCHAR2(10)
)TABLESPACE TEST_TBS_NEW;

-- ALTER 
ALTER TABLE TB_TEST2 RENAME TO NEW_TB_TEST2;

--COLOUMN 추가  
ALTER TABLE NEW_TB_TEST2
ADD NEW_COL VARCHAR2(30);

--다중 COLOUMN 추가
ALTER TABLE NEW_TB_TEST2
ADD(NEW_COL1 VARCHAR2(30));

--단일 컬럼 수정
ALTER TABLE NEW_TB_TEST2
MODIFY NEW_COL1 VARCHAR2(20);

ALTER TABLE NEW_TB_TEST2
DROP COLUMN NEW_COL1; -- 다중 컬럼 삭제시 COLUMN을 빼고 괄호로 묶어준다.


-- 단일 컬럼 이름 수정
ALTER TABLE NEW_TB_TEST2
RENAME COLUMN COL1 TO COL_1;

-- 테이블 복제 (데이터 포함) (ROW 포함)
CREATE TABLE NEW_TB_TEST3
AS 
SELECT * FROM HR.JOBS;

--테이블 복제 (데이터 미포함) (ROW 미포함)
CREATE TABLE NEW_TB_TEST4
AS
SELECT * 
FROM HR.JOBS
WHERE 1 = 2; -- 성립될 수 없는 조건

--테이블 명을 수정
ALTER TABLE NEW_TB_TEST4
RENAME TO TB_TEST4;

--테이블 삭제
DROP TABLE TB_TEST4 CASCADE CONSTRAINT;

-- 기존의 휴지통 비우기
PURGE RECYCLEBIN;

FLASHBACK TABLE TB_TEST4 TO BEFORE DROP;

/*
CONSTRAINT : 제약조건

PRIMARY KEY (PK) : 첫번째 키 -> 유일키 NOT NULL + UNIQUE = ID
                  유일한 값 + NOT NULL
UNIQUE KEY (UK) : 현재 테이블 내에서 유일해야 한다. + NULL허용
FOREIGN KEY (FK) : 외래키 (다른 테이블에서 PRIMARY KEY로 형성) NULL을 허용
NOT NULL : NULL을 불허
CHECK : 남 : 여
*/

CREATE TABLE TB_TEST(
  COL_01 VARCHAR2(10) NOT NULL,
  COL_02 VARCHAR2(20)
);

INSERT INTO TB_TEST(COL_01, COL_02)
VALUES('AAA', 'aaa');

INSERT INTO TB_TEST(COL_01, COL_02)
VALUES('BBB', '');

INSERT INTO TB_TEST(COL_01, COL_02)
VALUES('', ''); -- 무결성의 에러

ALTER TABLE TB_TEST
MODIFY COL_02 VARCHAR2(20) NOT NULL; -- NUL -> NOT NULL은 수정 불가! 지우고 다시 만들어야 한다.

ALTER TABLE TB_TEST
MODIFY COL_01 VARCHAR2(20) NULL; -- NOT NULL -> NULL은 가능!

-- PRIMARY KEY
CREATE TABLE TEST_01(
  PKEY_01 VARCHAR2(10) CONSTRAINT PK_TEST_01 PRIMARY KEY,
  COL_01 VARCHAR2(100),  
  COL_02 VARCHAR2(100)
);

INSERT INTO TEST_01(PKEY_01, COL_01, COL_02)
VALUES('ABC', 'abc', '');

INSERT INTO TEST_01(PKEY_01, COL_01, COL_02)
VALUES('AB', '', '');

DROP TABLE TEST_01 CASCADE CONSTRAINTS;

CREATE TABLE TEST_01(
  PKEY_01 VARCHAR2(10),
  PKEY_02 VARCHAR2(10),
  COL_01 VARCHAR2(100),  
  COL_02 VARCHAR2(100),
  CONSTRAINT PK_TEST_01 PRIMARY KEY(PKEY_01, PKEY_02)
  USING INDEX TABLESPACE USERS
);

CREATE TABLE TEST_01(
  PKEY_01 VARCHAR2(10),
  PKEY_02 VARCHAR2(10),
  COL_01 VARCHAR2(100),  
  COL_02 VARCHAR2(100)
);

ALTER TABLE TEST_01
ADD CONSTRAINT PK_TEST_01
PRIMARY KEY(PKEY_01, PKEY_02)
  USING INDEX TABLESPACE USERS;

--PRIMARY KEY 확인
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TEST_01' AND CONSTRAINT_TYPE='P';

ALTER TABLE TEST_01
DROP PRIMARY KEY;

--UNIQUE 테이블 내에서 유일하다
--NULL 허용, 유일한 값을 갖는다, 중복 불허
CREATE TABLE TEST_02(
  UKEY_01 VARCHAR2(10) CONSTRAINT UK_TEST_01 UNIQUE, 
  COL_01 VARCHAR2(20),
  COL_02 VARCHAR2(20)
);

INSERT INTO TEST_02(UKEY_01, COL_01, COL_02)
VALUES('DDD', 'aaaa', '111');

INSERT INTO TEST_02(UKEY_01, COL_01, COL_02)
VALUES('DD', 'aaa', '111');

INSERT INTO TEST_02(UKEY_01, COL_01, COL_02)
VALUES('', '', '111');

--CHECK NULL 허용
CREATE TABLE TEST_03(
  KEY_01 VARCHAR2(10),
  KEY_02 VARCHAR2(10),
  COL_01 VARCHAR2(100),
  COL_02 NUMBER,
  CONSTRAINT CHK_TEST_01 CHECK(COL_01 IN('남자', '여자', '기타')),
  CONSTRAINT CHK_TEST_02 CHECK(COL_02 >= 1 AND COL_02 <= 999)
);

INSERT INTO TEST_03(KEY_01, KEY_02, COL_01, COL_02)
VALUES('AAA', 'aaa', '', 1);

INSERT INTO TEST_03(KEY_01, KEY_02, COL_01, COL_02)
VALUES('AAA', 'aaa', '남자', 2);

INSERT INTO TEST_03(KEY_01, KEY_02, COL_01, COL_02)
VALUES('AAA', 'aaa', '기타', 999);

--기존 테이블에 체크 추가

CREATE TABLE TEST_04(
  KEY_01 VARCHAR2(10),
  KEY_02 VARCHAR2(10),
  COL_01 VARCHAR2(100),
  COL_02 NUMBER
);

ALTER TABLE TEST_04
ADD (
  CONSTRAINT CHK_TEST_01_1
    CHECK (COL_01 IN ('남자', '여자')),
  CONSTRAINT CHK_TEST_01_2
  CHECK (COL_02 > 1 AND COL_02 <= 3)
  );
  
ALTER TABLE TEST_04
DROP CONSTRAINT CHK_TEST_01_1;

--FOREIGN KEY
/*
부모(다른) 테이블 기본키(PRIMARY KEY)나 고유키(UNIQUE KEY)만 참조가능

외래키가 설정되면, 부모(다른)테이블을 삭제하거나
자식(본) 테이블에서 컬럼의 값을 삭제/변경 불가능

NULL이 허용
*/

CREATE TABLE TEST_PAR(
  KEY_01 VARCHAR2(10),
  KEY_02 VARCHAR2(10),
  COL_01 VARCHAR2(100),
  UK_KEY_01 VARCHAR2(10),
  UK_KEY_02 VARCHAR2(10),
  CONSTRAINT PK_TEST_PAR PRIMARY KEY(KEY_01, KEY_02),
  CONSTRAINT UK_TEST_PAR UNIQUE(UK_KEY_01, UK_KEY_02)
);

CREATE TABLE TEST_CHD(
  KEY_01 VARCHAR2(10) CONSTRAINT PK_TEST_CHD PRIMARY KEY,
  COL_01 VARCHAR2(100),
  COL_02 VARCHAR2(100),
  FK1_KEY_01 VARCHAR2(10),
  FK2_KEY_02 VARCHAR2(10),
  CONSTRAINT FK1_TEST_CHD FOREIGN KEY(FK1_KEY_01, FK2_KEY_02)
  REFERENCES TEST_PAR(KEY_01, KEY_02)
);

INSERT INTO TEST_PAR(KEY_01, KEY_02, COL_01, UK_KEY_01, UK_KEY_02)
VALUES ('AAA', 'aaa', 's', 'A', 'a');

INSERT INTO TEST_PAR(KEY_01, KEY_02, COL_01, UK_KEY_01, UK_KEY_02)
VALUES ('BBB', 'bbb', 'd', 'B', 'b');

INSERT INTO TEST_PAR(KEY_01, KEY_02, COL_01, UK_KEY_01, UK_KEY_02)
VALUES ('CCC', 'ccc', 'f', 'c', 'c');

INSERT INTO TEST_CHD(KEY_01, COL_01, COL_02, FK1_KEY_01, FK2_KEY_02)
VALUES ('456', 'XXX', 'YYY', 'AAA', 'aaa');

INSERT INTO TEST_CHD(KEY_01, COL_01, COL_02, FK1_KEY_01, FK2_KEY_02)

--문제1) EMPLOYEES 테이블에서 부서별로 인원수,평균 급여,급여의 합,최소 급여,최대 급여를 포함하는 EMP_DEPTNO 테이블을 생성하라.

CREATE TABLE EMP_DEPNO(
  DEPARTMENT_ID,
  DEPARTMENT_COUNT,
  DEPARTMENT_AVG,
  DEPARTMENT_SUM,
  DEPARTMENT_MIN,
  DEPARTMENT_MAX
)AS
SELECT DEPARTMENT_ID, COUNT(*), AVG(SALARY), SUM(SALARY), MIN(SALARY), MAX(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

--문제2) EMP_DEPTNO 테이블에 ETC COLUMN을 추가하라. 
--단 자료형은 VARCHAR2(50) 사용하라.

ALTER TABLE EMP_DEPNO
ADD ETC_COLUMN VARCHAR2(50);

--문제3) EMP_DEPTNO 테이블에 ETC COLUMN을 수정하라. 
--자료 형은 VARCHAR2(15)로 하라.

ALTER TABLE EMP_DEPNO
MODIFY ETC_COLUMN VARCHAR2(15);

--문제4) EMP_DEPTNO 테이블에 있는 ETC 을 삭제하고 확인하라.

ALTER TABLE EMP_DEPNO
DROP COLUMN ETC_COLUMN;

--문제5) 이전에 생성한 EMP_DEPTNO 테이블의 이름을 EMP_DEPT로 변경하라.

ALTER TABLE EMP_DEPNO
RENAME TO EMP_DEPT;

--문제6) EMP_DEPT 테이블을 삭제하라.

DROP TABLE EMP_DEPT CASCADE CONSTRAINTS PURGE;

--문제7) EMPLOYEES 테이블을 EMP 테이블을 생성하고 복제하도록 하라.
--(데이터 포함)

CREATE TABLE EMP
AS SELECT *
FROM EMPLOYEES;

--문제8) EMP 테이블에 row를 추가해 봅니다.
--다만, 반드시 데이터를 기입을 안해도 되면, NULL로 설정하도록 한다.

INSERT INTO EMP(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
VALUES(207, 'Hanju', 'Bae', 'FAITHBAE41', '650.505.7558', '16/12/13', 'IT_PROG', 22223, NULL, NULL, 80);

SELECT * FROM 
EMP;

--문제9) EMPLOYEES 테이블에서 EMPNO,ENAME,SAL,HIREDATE의 COLUMN만 선택하여 EMP_10 테이블을 생성(데이터 미포함)한 후 10번 부서만 선택하여 
--이에 대응하는 값을 EMP_10테이블에 입력하라.


CREATE TABLE EMP1(
  EMPNO,
  ENAME,
  SAL,
  HIREDATE
)
AS SELECT EMPLOYEE_ID, LAST_NAME, SALARY, HIRE_DATE 
FROM EMPLOYEES
WHERE 1 = 2;


INSERT INTO EMP1
SELECT EMPLOYEE_ID, LAST_NAME, SALARY, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 10;



