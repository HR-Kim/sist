/*
  ORDER BY : 정렬
  
*/

SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY;  --오름

SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC; -- 내림

SELECT first_name, MANAGER_ID
FROM EMPLOYEES
ORDER BY MANAGER_ID NULLS FIRST;

SELECT FIRST_NAME, SALARY, MANAGER_ID
FROM EMPLOYEES
ORDER BY MANAGER_ID NULLS FIRST, SALARY DESC;

--별명
SELECT FIRST_NAME, salary*12 AS 연봉
FROM EMPLOYEES
ORDER BY 연봉 DESC;

--중복행의 제거
SELECT * FROM EMPLOYEES;

SELECT DISTINCT JOB_ID
FROM EMPLOYEES;

--GROUP
SELECT JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT DEPARTMENT_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT MANAGER_ID
FROM EMPLOYEES
GROUP BY MANAGER_ID;

--그룹함수
  /*
  SUM : 합계
  AVG : 평균
  COUNT : ROW 수
  MAX : 최대값
  MIN : 최소값
  STDDEV : 표준편차
  VARIANCE : 분산
  
  */

SELECT COUNT(*)
FROM EMPLOYEES;



SELECT * 
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

SELECT COUNT(SALARY), SUM(SALARY), SUM(SALARY) / COUNT(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

UPDATE EMPLOYEES SET SALARY = NULL
WHERE JOB_ID = 'IT_PROG';

SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

ROLLBACK;

SELECT COUNT(SALARY), SUM(SALARY), AVG(SALARY), MAX(SALARY), MIN(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

--HABING

SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING SUM(SALARY) > 20000;   --GROUP BY에 대한 조건절

SELECT DEPARTMENT_ID, JOB_ID, COUNT(SALARY), SUm(SALARY), AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;

-- OVER

SELECT FIRST_NAME, JOB_ID,
COUNT(*)OVER(PARTITION BY JOB_ID),
SUM(SALARY)OVER(PARTITION BY JOB_ID),
SUM(SALARY)OVER(PARTITION BY DEPARTMENT_ID)
FROM EMPLOYEES;

--문제1) EMPLOYEES 테이블에서 입사일자 순으로 정렬하여 사원번호, 이름, 업무, 급여, 입사일자,부서번호를 출력하라.

SELECT HIRE_DATE, employee_id, LAST_NAME, JOB_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY HIRE_DATE;

--문제2) EMPLOYEES 테이블에서 가장 최근에 입사한 순으로 사원번호, 이름, 업무, 급여, 입사일자,부서번호를 출력하라.

SELECT HIRE_DATE, employee_id, LAST_NAME, JOB_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;

--문제3) EMPLOYEES 테이블에서 부서번호로 정렬한 후 부서번호가 같을 경우 급여가 많은 순으로 정렬하여 사원번호, 성명, 업무, 부서번호, 급여를 출력하여라.

SELECT DEPARTMENT_ID, SALARY, EMPLOYEE_ID, LAST_NAME, JOB_ID
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;

--문제4) EMPLOYEES 테이블에서 첫번째 정렬은 부서번호로 
두번째 정렬은 업무로 세번째 정렬은 급여가 많은 순으로 정렬하여 사원번호, 
성명, 입사일자, 부서번호, 업무, 급여를 출력하여라.

SELECT DEPARTMENT_ID, JOB_ID, SALARY, EMPLOYEE_ID, LAST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID, JOB_ID, SALARY DESC;

--문제1) 부서별로 담당하는 업무를 한번씩 출력하여라.
SELECT DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;

SELECT DISTINCT DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES;

-- ROWNUM
  SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM EMPLOYEES;

  SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY
  FROM (
  SELECT * 
  FROM EMPLOYEES 
  ORDER BY SALARY DESC);

-- ROW_NUMBER()
SELECT FIRST_NAME, JOB_ID, DEPARTMENT_ID, SALARY,
ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC)
FROM EMPLOYEES;

--NVL, NVL2 -> 3항연산자 (조건)? 참 : 거짓
SELECT EMPLOYEE_ID, NVL(MANAGER_ID, 0) AS 매니저
FROM EMPLOYEES;

--NVL(VALUE , 거짓)
--NVL2( VALUE, 참, 거짓)
--DECODE(VALUE , NULL, 값1, 값2) == (VALUE == NULL)?"값1":"값2"
SELECT EMPLOYEE_ID, NVL2(MANAGER_ID, 1, 0) AS 매니저
FROM EMPLOYEES;

SELECT EMPLOYEE_ID, DECODE(MANAGER_ID, NULL, 1, 0) AS 매니저
FROM EMPLOYEES;

/*
문제1) EMPLOYEES 테이블에서 King의 정보를 소문자로 검색하고 사원번호,성명, 담당업무(소문자로),부서번호를 출력하라.
*/

SELECT EMPLOYEE_ID, LAST_NAME, LOWER(JOB_ID), DEPARTMENT_ID
FROM EMPLOYEES
WHERE LOWER(LAST_NAME) = 'king';

/*
문제2) EMPLOYEES 테이블에서 King의 정보를 대문자로 검색하고 사원번호,
성명, 담당업무(대문자로),부서번호를 출력하라.
*/

SELECT EMPLOYEE_ID, LAST_NAME, UPPER(JOB_ID), DEPARTMENT_ID
FROM EMPLOYEES
WHERE UPPER(LAST_NAME) = 'KING';

/*
문제3) DEPARTMENTS 테이블에서 부서번호와 부서이름, 부서이름과 위치번호를 합하여 출력하도록 하라.
*/

SELECT DEPARTMENT_ID || DEPARTMENT_NAME, LOCATION_ID || DEPARTMENT_NAME
FROM DEPARTMENTS;

/*
문제4) EMPLOYEES 테이블에서 이름의 첫 글자가 ‘K’ 보다 크고 ‘Y’보다 적은 사원의 정보를 사원번호, 이름, 업무, 급여, 부서번호를 출력하라. 
단 이름순으로 정렬하여라.
*/

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE LAST_NAME > 'Kz%' AND LAST_NAME < 'Y%'
ORDER BY LAST_NAME;

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SUBSTR(LAST_NAME, 1, 1) > 'K'
  AND SUBSTR(LAST_NAME, 1, 1) < 'Y'
  ORDER BY LAST_NAME;

--문제5) EMPLOYEES 테이블에서 20번 부서 중  이름의 길이 및 급여의 자릿수를 사원번호, 이름, 이름의 자릿수, 급여, 급여의 자릿수를 출력하라.

SELECT DEPARTMENT_ID, EMPLOYEE_ID, LAST_NAME, LENGTH(LAST_NAME), SALARY, LENGTH(SALARY)
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN 20 ;

--문제6) EMPLOYEES 테이블에서 이름 중 ‘e’자의 위치를 출력하라.
SELECT LAST_NAME, INSTRB(LAST_NAME,'e', 1) AS E_1, INSTRB(LAST_NAME,'e', 2) AS E_2 
FROM EMPLOYEES;

--INSTR('비교할 대상', '비교하고자 하는 값', '시작위치', '검색결과수')

SELECT ROUND(4567.678),ROUND(4567.678,0),
ROUND(4567.678,2),ROUND(4567.678,-2)
FROM dual;

--문제8) EMPLOYEES 테이블에서 부서번호가 80인 사람의 급여를 30으로 나눈 나머지를 구하여 출력하라.

SELECT DEPARTMENT_ID, EMPLOYEE_ID, SALARY, MOD(SALARY,30)
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 80;

--문제9) EMPLOYEES 테이블에서 30번 부서 중 이름과 담당 업무를 연결하여 출력하여라. 단 담당 업무를 한 줄 아래로 출력하라.

SELECT LAST_NAME ||  CHR (10)  || JOB_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30;

--문제10) EMPLOYEES 테이블에서 현재까지 근무일 수가 몇주 몇일 인가를 출력하여라. 단 근무 일수가 많은 사람 순으로 출력하여라.

SELECT LAST_NAME, HIRE_DATE, SYSDATE, ROUND(SYSDATE-HIRE_DATE) AS "Total Day",
FLOOR((SYSDATE - HIRE_DATE)/7) AS WEEK,
ROUND(SYSDATE-HIRE_DATE) - (FLOOR((SYSDATE - HIRE_DATE)/7)*7) AS TD
--"Total Day" - (WEEK*7) AS DAYS
FROM EMPLOYEES
ORDER BY "Total Day" DESC;  

--문제11) EMPLOYEES 테이블에서 부서 50에서 급여 앞에 $를 삽입하고 3자리마다 ,를 출력하라

SELECT DEPARTMENT_ID, LAST_NAME, JOB_ID, SALARY, TO_CHAR(SALARY, '$999,999')
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 50
ORDER BY SALARY DESC;

--문제12) 다음의 결과를 분석하여 보아라.

SELECT EMPLOYEE_ID, LAST_NAME, JOB_ID, SALARY, NVL(commission_pct*salary+SALARY, SALARY) AS D_SAL
FROM EMPLOYEES
WHERE SALARY > 9500

ORDER BY SALARY DESC;
SELECT * FROM EMPLOYEES;
--문제1) EMPLOYEES 테이블에서 모든 SALESMAN(SA_MAN)에 대하여 급여의 평균, 최고액, 최저액, 합계를 구하여 출력하여라.
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY), SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING JOB_ID = 'SA_MAN';

--문제2) EMPLOYEES 테이블에 등록되어 있는 인원수, 보너스가 NULL이 아닌 인원수, 보너스의 평균, 등록되어 있는 부서의 수를 구하여 출력하라.

SELECT COUNT(*), SUM(NVL2(COMMISSION_PCT, 1,0)), AVG(commission_pct*salary), COUNT(DISTINCT DEPARTMENT_ID)
FROM EMPLOYEES;


--문제3) EMPLOYEES 테이블에서 부서별로 인원수, 평균 급여, 최저급여, 최고 급여, 급여의 합을 구하여 출력하라.

SELECT DISTINCT DEPARTMENT_ID, COUNT(*)OVER(PARTITION BY DEPARTMENT_ID),
AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
MAX(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID)
FROM EMPLOYEES;

SELECT DISTINCT DEPARTMENT_ID, COUNT(*)OVER(PARTITION BY DEPARTMENT_ID),
AVG(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
MIN(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
MAX(SALARY) OVER(PARTITION BY DEPARTMENT_ID),
SUM(SALARY) OVER(PARTITION BY DEPARTMENT_ID) AS "SUM(SALARY)"
FROM EMPLOYEES
ORDER BY "SUM(SALARY)" DESC;

--문제5) EMPLOYEES 테이블에서 부서별, 업무별 그룹하여 결과를 부서번호, 업무, 인원수, 급여의 평균, 급여의 합을 구하여 출력하여라.

SELECT DEPARTMENT_ID, JOB_ID,
COUNT(*),
AVG(SALARY),
SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;

--문제6) EMPLOYEES 테이블에서 부서 인원이 4명보다 많은 부서의 부서번호, 인원수, 급여의 합을 구하여 출력하여라.(GROUP BY, HAVING)

SELECT DEPARTMENT_ID,
COUNT(*),
SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 4;

--문제7) EMPLOYEES 테이블에서 급여가 최대 10000이상인 부서에 대해서 부서번호, 평균 급여, 급여의 합을 구하여 출력하여라.

SELECT DEPARTMENT_ID,
AVG(SALARY),
SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING SUM(SALARY) > 10000; --오답

SELECT DEPARTMENT_ID,
AVG(SALARY),
SUM(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING MAX(SALARY) > 10000;


--문제8) EMPLOYEES 테이블에서 업무별 급여의 평균이 10000 이상인 업무에 대해서 업무명,평균 급여, 급여의 합을 구하여 출력하라.

SELECT JOB_ID,
AVG(SALARY),
SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) > 10000;

--문제9) EMPLOYEES 테이블에서 전체 월급이 10000을 초과하는 각 업무에 대해서 업무와 월급여 합계를 출력하라. 단 판매원은 제외하고 월 급여 합계로 정렬(내림차순)하라.(SA_)

SELECT JOB_ID, SUM(SALARY) AS PAYROLL
FROM EMPLOYEES
--WHERE JOB_ID NOT LIKE 'SA%'
GROUP BY JOB_ID
HAVING SUM(salary) > 10000
--AND JOB_ID NOT LIKE 'SA%'
ORDER BY SUM(SALARY) DESC;
